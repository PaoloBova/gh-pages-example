# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_payoffs1.ipynb.

# %% auto 0
__all__ = ['payoffs_sr', 'payoffs_sr_pfo_extension', 'payoffs_lr', 'payoffs_lr_peer_punishment', 'payoffs_lr_peer_reward',
           'payoffs_lr_voluntary']

# %% ../nbs/02_payoffs1.ipynb 2
from nbdev.showdoc import *
from fastcore.test import test_eq
from .utils import *
import typing

import numpy as np
import nptyping

# %% ../nbs/02_payoffs1.ipynb 5
def payoffs_sr(models):
    """The short run payoffs for the DSAIR game."""
    s, b, c = [models[k] for k in ['s', 'b', 'c']]
    πAA = -c + b/2
    πAB = -c + b/(s+1)
    πBA = s*b/(s+1)
    πBB = b/2
    matrix = np.block([[πAA, πAB], 
                       [πBA, πBB]])
    return {**models, 'payoffs_sr':matrix}

# %% ../nbs/02_payoffs1.ipynb 7
def payoffs_sr_pfo_extension(model):
    """The short run payoffs for the DSAIR game with a chance of unsafe
    behaviour being spotted."""
    s, b, c, pfo = [model[k] for k in ['s', 'b', 'c', 'pfo']]
    πAA =  -c + b/2
    πAB = -c + b/(s+1) * (1 - pfo) + pfo * b
    πBA = (1 - pfo) * s * b / (s+1)
    πBB = (1 - pfo**2) * b/2
    matrix = np.block([[πAA, πAB],
                       [πBA, πBB]])
    return {**model, 'payoffs_sr':matrix}

# %% ../nbs/02_payoffs1.ipynb 9
def payoffs_lr(model):
    """The long run average payoffs for the DSAIR game."""
    s, p, B, W = [model[k] for k in ['s', 'p', 'B', 'W']]
    πAA,πAB,πBA,πBB = [model['payoffs_sr'][:, i:i+1, j:j+1]
                       for i in range(2) for j in range(2)]
    πAA = πAA + B/(2*W)
    πAB = πAB
    πBA = p*(s*B/W + πBA)
    πBB = p*(s*B/(2*W) + πBB)
    payoffs = np.block([[πAA, πAB],
                        [πBA, πBB]])
    return {**model, 'payoffs': payoffs}

# %% ../nbs/02_payoffs1.ipynb 11
def payoffs_lr_peer_punishment(model):
    """The long run average payoffs for the DSAIR game with peer punishment."""
    s,b,c, p, B, W = [model[k] for k in ['s', 'b', 'c', 'p', 'B', 'W']]
    α, γ, ϵ = [model[k] for k in ['α', 'γ', 'ϵ']]
    πAA,πAB,πBA,πBB = [model['payoffs_sr'][:, i:i+1, j:j+1]
                       for i in range(2) for j in range(2)]
    
    s_punished = s - γ
    s_sanctioner = s - α
    punished_wins = (s > γ) & ((W-s)/(s-γ) <= (W-1)/(s-α))
    punished_draws = (s > γ) & ((W-s)/(s-γ) == (W-1)/(s-α))
    sanctioner_wins = (s > α) & ((W-s)/(s-γ) >= (W-1)/(s-α))
    no_winner = (s_punished <= 0) & (s_sanctioner <= 0)

    both_speeds_positive = (s_punished > 0) & (s_sanctioner > 0)
    only_sanctioner_speed_positive = (s_punished <= 0) & (s_sanctioner > 0)
    only_punisher_speed_positive = (s_punished > 0) & (s_sanctioner <= 0)

    p_loss = np.where(punished_wins | punished_draws, p, 1)
    R = np.where(no_winner,
                 np.inf,
                 1 + np.minimum((W-s)/ np.maximum(s_punished, 1e-10),
                                (W-1)/ np.maximum(s_sanctioner, 1e-10)))
    B_s = np.where(sanctioner_wins, B, np.where(punished_draws, B/2, 0))
    B_p = np.where(punished_wins, B, np.where(punished_draws, B/2, 0))
    b_s = np.where(both_speeds_positive,
                   b * (s - α)/(s-γ + s - α),
                   np.where(only_sanctioner_speed_positive, b, 0))
    b_p = np.where(both_speeds_positive,
                   b * (s - γ)/(s-γ + s - α),
                   np.where(only_punisher_speed_positive, b, 0))

    sanctioner_payoff = (1 / R) * (πAB + B_s + (R-1)*(b_s - c)) - ϵ
    punished_payoff = (p_loss / R) * (πBA + B_p + (R-1)*b_p) - ϵ
    
    ΠAA = πAA + B/(2*W)
    ΠAB = p*(s*B/W + πBA)
    ΠAC = πAA + B/(2*W)
    ΠBA = p*(s*B/W + πBA)
    ΠBB = p*(s*B/(2*W) + πBB)
    ΠBC = punished_payoff
    ΠCA = πAA + B/(2*W)
    ΠCB = sanctioner_payoff
    ΠCC = πAA + B/(2*W)
    matrix = np.block([[ΠAA, ΠAB, ΠAC], 
                       [ΠBA, ΠBB, ΠBC],
                       [ΠCA, ΠCB, ΠCC],
                       ])
    return {**model, 'payoffs':matrix}

# %% ../nbs/02_payoffs1.ipynb 15
def payoffs_lr_peer_reward(model):
    """The long run average payoffs for the DSAIR game with peer punishment."""
    s,b,c, p, B, W = [model[k] for k in ['s', 'b', 'c', 'p', 'B', 'W']]
    α, γ, ϵ = [model[k] for k in ['α', 'γ', 'ϵ']]
    πAA,πAB,πBA,πBB = [model['payoffs_sr'][:, i:i+1, j:j+1]
                       for i in range(2) for j in range(2)]
    
    s_rewarded = s + γ
    s_helper = s - α
    ΠAA = πAA + B/(2*W)
    ΠAB = p*(s*B/W + πBA)
    ΠAC = πAA + B * s_rewarded / ((s_rewarded + s_helper) * W)
    ΠBA = p*(s*B/W + πBA)
    ΠBB = p*(s*B/(2*W) + πBB)
    ΠBC = p*(s*B/W + πBA)
    ΠCA = πAA
    ΠCB = πAB
    ΠCC = πAA + B * (1 + s_rewarded - s_helper)/(2*W)
    matrix = np.block([[ΠAA, ΠAB, ΠAC], 
                       [ΠBA, ΠBB, ΠBC],
                       [ΠCA, ΠCB, ΠCC],
                       ])
    return {**model, 'payoffs':matrix}

# %% ../nbs/02_payoffs1.ipynb 17
def payoffs_lr_voluntary(model):
    """The long run average payoffs for the DSAIR game with voluntary
    commitments."""
    s,b,c, p, B, W = [model[k] for k in ['s', 'b', 'c', 'p', 'B', 'W']]
    α, γ, ϵ = [model[k] for k in ['α', 'γ', 'ϵ']]
    πAA,πAB,πBA,πBB = [model['payoffs_sr'][:, i:i+1, j:j+1]
                       for i in range(2) for j in range(2)]
    
    s_punished = s - γ
    s_sanctioner = s - α
    punished_wins = (s > γ) & ((W-s)/(s-γ) <= (W-1)/(s-α))
    punished_draws = (s > γ) & ((W-s)/(s-γ) == (W-1)/(s-α))
    sanctioner_wins = (s > α) & ((W-s)/(s-γ) >= (W-1)/(s-α))
    no_winner = (s_punished <= 0) & (s_sanctioner <= 0)

    both_speeds_positive = (s_punished > 0) & (s_sanctioner > 0)
    only_sanctioner_speed_positive = (s_punished <= 0) & (s_sanctioner > 0)
    only_punisher_speed_positive = (s_punished > 0) & (s_sanctioner <= 0)

    p_punish = np.where(punished_wins | punished_draws, p, 1)
    R = np.where(no_winner,
                 np.inf,
                 1 + np.minimum((W-s)/ np.maximum(s_punished, 1e-10),
                                (W-1)/ np.maximum(s_sanctioner, 1e-10)))
    B_s = np.where(sanctioner_wins, B, np.where(punished_draws, B/2, 0))
    B_p = np.where(punished_wins, B, np.where(punished_draws, B/2, 0))
    b_s = np.where(both_speeds_positive,
                   b * (s - α)/(s-γ + s - α),
                   np.where(only_sanctioner_speed_positive, b, 0))
    b_p = np.where(both_speeds_positive,
                   b * (s - γ)/(s-γ + s - α),
                   np.where(only_punisher_speed_positive, b, 0))

    sanctioner_payoff = (1 / R) * (πAB + B_s + (R-1)*(b_s - c)) - ϵ
    punished_payoff = (p_punish / R) * (πBA + B_p + (R-1)*b_p) - ϵ
    
    ΠAA = πAA + B/(2*W)
    ΠAB = πAB
    ΠAC = πAB
    ΠAD = πAB
    ΠAE = πAB
    ΠBA = p*(s*B/W + πBA)
    ΠBB = p*(s*B/(2*W) + πBB)
    ΠBC = p*(s*B/(2*W) + πBB)
    ΠBD = p*(s*B/(2*W) + πBB)
    ΠBE = p*(s*B/(2*W) + πBB)
    ΠCA = p*(s*B/W + πBA)
    ΠCB = p*(s*B/(2*W) + πBB)
    ΠCC = πAA + B/(2*W) - ϵ
    ΠCD = πAB - ϵ
    ΠCE = πAA + B/(2*W) - ϵ
    ΠDA = p*(s*B/W + πBA)
    ΠDB = p*(s*B/(2*W) + πBB)
    ΠDC = p*(s*B/W + πBA) - ϵ
    ΠDD = p*(s*B/(2*W) + πBB) - ϵ
    ΠDE = punished_payoff - ϵ
    ΠEA = p*(s*B/W + πBA) - ϵ
    ΠEB = p*(s*B/(2*W) + πBB)
    ΠEC = πAA + B/(2*W) - ϵ
    ΠED = sanctioner_payoff - ϵ
    ΠEE = πAA + B/(2*W) - ϵ
    matrix = np.block([[ΠAA, ΠAB, ΠAC, ΠAD, ΠAE], 
                       [ΠBA, ΠBB, ΠBC, ΠBD, ΠBE],
                       [ΠCA, ΠCB, ΠCC, ΠCD, ΠCE],
                       [ΠDA, ΠDB, ΠDC, ΠDD, ΠDE],
                       [ΠEA, ΠEB, ΠEC, ΠED, ΠEE]
                       ])
    return {**model, 'payoffs':matrix}
