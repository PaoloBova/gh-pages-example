# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Analysis/11_analysis_regulator_markets.ipynb.

# %% auto 0
__all__ = ['valid_dtypes', 'Z', 'β', 'sector_strategies', 'allowed_sectors', 'models', 'results', 'result_sums', 'df', 'table',
           'build_reg_market']

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 2
from .conditions import *
from .data_utils import *
from .methods import *
from .model_utils import *
from .payoffs import *
from .plot_utils import *
from .types import *
from .utils import *

import copy
import typing
import warnings

import fastcore.test
import matplotlib as mpl
import matplotlib.pyplot as plt
from nbdev.showdoc import *
import nptyping
import numpy as np
import pandas
import seaborn as sns

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 5
valid_dtypes = typing.Union[float, list[float], np.ndarray, dict]
def build_reg_market(b:valid_dtypes=4, # benefit: The size of the per round benefit of leading the AI development race, b>0
                c:valid_dtypes=1, # cost: The cost of implementing safety recommendations per round, c>0
                s:valid_dtypes={"start":1, # speed: The speed advantage from choosing to ignore safety recommendations, s>1
                                "stop":5.1,
                                "step":0.1}, 
                p:valid_dtypes={"start":0, # avoid_risk: The probability that unsafe firms avoid an AI disaster, p ∈ [0, 1]
                                "stop":1.02,
                                "step":0.02}, 
                B:valid_dtypes=10**4, # prize: The size of the prize from winning the AI development race, B>>b
                W:valid_dtypes=100, # timeline: The anticipated timeline until the development race has a winner if everyone behaves safely, W ∈ [10, 10**6]
                pfo_l:valid_dtypes=0, # detection_risk_lq: The probability that firms who ignore safety precautions are found out by high quality regulators, pfo_h ∈ [0, 1]
                pfo_h:valid_dtypes=0.5, # detection_risk_hq: The probability that firms who ignore safety precautions are found out by low quality regulators, pfo_h ∈ [0, 1]
                λ:valid_dtypes=0, # disaster_penalty: The penalty levied to regulators in case of a disaster
                r_l:valid_dtypes=0, # profit_lq: profits for low quality regulators before including government incentives, r_l ∈ R
                r_h:valid_dtypes=-1, # profit_hq: profits for high quality regulators before including government incentives, r_h ∈ R
                g:valid_dtypes=1, # government budget allocated to regulators per firm regulated, g > 0
                collective_risk:valid_dtypes=0, # The likelihood that a disaster affects all actors
                β:valid_dtypes=1, # learning_rate: the rate at which players imitate each other
                Z:dict={"S1": 50, "S2": 50}, # population_size: the number of firms and regulators
                strategy_set:list[str]=["HQ-AS", "HQ-AU", "HQ-VS",
                                        "LQ-AS", "LQ-AU", "LQ-VS"], # the set of strategy combinations across all sectors
                exclude_args:list[str]=['Z', 'strategy_set'], # a list of arguments that should be returned as they are
                override:bool=False, # whether to build the grid if it is very large
                drop_args:list[str]=['override', 'exclude_args', 'drop_args'], # a list of arguments to drop from the final result
               ) -> dict: # A dictionary containing items from `ModelTypeRegMarket` and `ModelTypeEGT`
    """Initialise Regulatory Market models for all combinations of the provided
    parameter valules."""
    
    saved_args = locals()
    models = model_builder(saved_args,
                           exclude_args=exclude_args,
                           override=override,
                           drop_args=drop_args)
    return models

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 12
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1_reward_after",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 31
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = build_reg_market(pfo_h=0.8, g=1)
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1_reward_after",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
            )

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
            )

plot_strategy_distribution(df[df.s==1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                          )

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 33
Z = {"S2": 100, "S1": 100}
β = 0.01
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = build_reg_market(pfo_h=0.8)
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1_reward_after",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
            )

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
            )

plot_strategy_distribution(df[df.s==1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                          )

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 36
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = build_reg_market(pfo_h=0.8, g=1.1)
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1_reward_before",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
            )

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
            )

plot_strategy_distribution(df[df.s==1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                          )

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 37
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = build_reg_market(pfo_h=0.8, g=1)
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1_reward_before",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
            )

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
            )

plot_strategy_distribution(df[df.s==1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                          )

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 43
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = build_reg_market(pfo_h=0.8, g=1.1, strategy_set=["HQ-AS", "HQ-AU",
                                                          "LQ-AS", "LQ-AU"])
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1_reward_before",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency'])

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
            )

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
            )

plot_strategy_distribution(df[df.s==1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                          )

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 44
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = build_reg_market(pfo_h=0.8, g=1.1)
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1a_reward_before",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
            )

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
            )

plot_strategy_distribution(df[df.s==1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                          )

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 46
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3],}
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"],}
models = build_reg_market(pfo_h=0.8, g=1.5)
models['incentive_mix'] = 1
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1_reward_mixed",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                      create_profiles,
                      apply_profile_filters,
                      build_payoffs,
                      build_transition_matrix,
                      find_ergodic_distribution,
                      )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
            )

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
            )

plot_strategy_distribution(df[df.s==1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                          )

# %% ../nbs/Analysis/11_analysis_regulator_markets.ipynb 48
Z = {"S2": 100, "S1": 100}
β = 1
sector_strategies = {"S2": [4, 5],
                     "S1": [1, 2, 3], }
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S1"],
                   "P1": ["S1"], }
models = build_reg_market(pfo_h=0.8, g=1.5)
models['incentive_mix'] = 1
models['pfo'] = 0.8
models = {**models,
          "dispatch-type": 'multiple-populations',
          "payoffs_key": "regulatory_markets_v1a_reward_before",
          "β": β,
          "Z": Z,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          }

results = thread_macro(models,
                       payoffs_sr_pfo_extension,
                       threshold_risk_dominant_safety_dsair,
                       threshold_society_prefers_safety_dsair,
                       create_profiles,
                       apply_profile_filters,
                       build_payoffs,
                       build_transition_matrix,
                       find_ergodic_distribution,
                       )
result_sums = np.sum(results['ergodic'], axis=-1)
fastcore.test.test_close(result_sums, 1)

df = thread_macro(results,
                  results_to_dataframe_egt,
                  process_dsair_data)
df['AU_frequency'] = (df['HQ-AU_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['LQ_frequency'] = (df['LQ-AS_frequency']
                      + df['LQ-AU_frequency']
                      + df['LQ-VS_frequency'])
df['AU_frequency_uncaught'] = (df['AU_frequency']
                               * ((1- df['LQ_frequency']) * (1 - df['pfo_h'])
                                  + df['LQ_frequency'] * (1 - df['pfo_l'])))

table = df.pivot_table(index='pr', columns='s', values='AU_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency',
             cmap='inferno',
             )

# Add threshold boundaries to convey dilemma region
plt.plot(table.columns, df[df.pr==1]['threshold_society_prefers_safety'])
plt.plot(table.columns, df[df.pr==1]['threshold_risk_dominant_safety']);

table = df.pivot_table(index='pr', columns='s', values='LQ_frequency')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='LQ Frequency',
             cmap='inferno',
             )

plot_strategy_distribution(df[df.s == 1.5],
                           results['strategy_set'],
                           x="pr",
                           thresholds=None,
                           )

table = df.pivot_table(index='pr', columns='s', values='AU_frequency_uncaught')
plot_heatmap(table,
             xlabel='Speed avantage, s',
             ylabel='Risk of an AI disaster, pr',
             zlabel='AU Frequency uncaught',
             cmap='inferno',
             )

