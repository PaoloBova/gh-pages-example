# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/utils.ipynb.

# %% auto 0
__all__ = ['thread_macro', 'broadcast_concatenate_axes', 'build_grid_from_axes', 'model_builder', 'multi', 'method', 'area']

# %% ../nbs/utils.ipynb 2
import fastcore
import functools
from nbdev.showdoc import *
import nptyping
import numpy as np

# %% ../nbs/utils.ipynb 3
def thread_macro(current_value, *funcs, identifier="self"):
    """Pipes current_value through each function in funcs.

    Each element in funcs is either a function or a list/tuple containing
    a function followed by its other arguments.
    This function imitates the Clojure as-if threading macro.

    Notes: By default current_value is threaded as the first argument of the
    function call. Yet, one can use the syntax [func, arg1, "self", arg2] (or
    (func, arg1, "self", arg2)) so that current_value will instead be threaded
    in whatever place "self" would be. If you need to, you can set this "self"
    identifier to a different value.
    """

    for func in funcs:
        if isinstance(func, (list, tuple)):
            place = 0
            for i, el in enumerate(func[1:]):
                if el == identifier:
                    place = i
                    func = [el for el in func if el != identifier]
            func, args1, args2 = func[0], func[1:place + 1], func[place + 1:]
            current_value = func(*args1, current_value, *args2)
        else:
            current_value = func(current_value)
    return current_value

# %% ../nbs/utils.ipynb 4
def broadcast_concatenate_axes(ax1, ax2):
    """Broadcast both numpy axes and concatenate along last dimension"""
    ax1new = ax1
    for _ in range(np.ndim(ax2) - 1):
        ax1new = ax1new[..., None, :]
    ax2new = ax2
    for _ in range(np.ndim(ax1) - 1):
        ax2new = ax2new[None, ..., :]
    ax1new = np.broadcast_to(ax1new,
                             (*ax1.shape[:-1], *ax2.shape[:-1], ax1.shape[-1]))
    ax2new = np.broadcast_to(ax2new,
                             (*ax1.shape[:-1], *ax2.shape[:-1], ax2.shape[-1]))
    ax = np.concatenate((ax1new, ax2new), axis=-1)
    return ax

# %% ../nbs/utils.ipynb 5
def build_grid_from_axes(axes:list, # Each axis in axes gives an array of values that should be repeated for each value in the other axes. Primitive types and lists of primitive types are first promoted to numpy arrays.
                         override:bool=False, # whether to build the grid if it is very large
                        ) -> np.ndarray: # A 2D numpy array with all combinations of elements specified in axes
    """Build a numpy array with all combinations of elements specified in axes."""

    dtypes = (float, int, bool, str)
    for i, axis in enumerate(axes):
        condition = isinstance(axis, dtypes) or all(
            isinstance(el, dtypes) for el in list(axis))
        axes[i] = np.array([axis]).T if condition else axis
    final_size = np.prod([axis.shape[0] for axis in axes])
    if (final_size > 5*10**6) & (not override):
        raise ValueError(f"""Your axes imply you want to create a grid with {final_size} > 5 million rows!
        If you're confident you can do this without crashing your computer, pass override=True to this function.""")
    tensor = functools.reduce(broadcast_concatenate_axes, axes)
    return tensor.reshape((-1, tensor.shape[-1]))

# %% ../nbs/utils.ipynb 13
def model_builder(saved_args:dict, # a dictionary containing parameters we want to vary or hold fixed
                  exclude_args:list[str]=[], # a list of arguments that should be returned as they are
                  override:bool=False, # whether to build the grid if it is very large
                  drop_args:list[str]=['override', 'exclude_args', 'drop_args'], # a list of arguments to drop from the final result
                 ) -> dict: # A dictionary containing items for the desired models
    """Build models for all combinations of the valules in `saved_args`."""
    axes_args1 = {k: np.array(v)
                  for k,v in saved_args.items()
                  if (isinstance(v, np.ndarray)
                      or (isinstance(v, list)
                          and all(isinstance(el, float) for el in v)))}
    axes_args2 = {k: np.arange(v["start"], v["stop"], v["step"])
                  for k,v in saved_args.items()
                  if (isinstance(v, dict)
                      and v.keys() == {"start", "stop", "step"})}
    axes_args = {**axes_args1, **axes_args2}
    grid = build_grid_from_axes(list(axes_args.values()),
                                override=override)
    models = {}
    # add grid parameters first
    for i, arg in enumerate(axes_args.keys()):
        models[arg] = grid[:, i]
    # add fixed parameters next
    for arg, v in saved_args.items():
        if arg not in (exclude_args
                       + drop_args
                       + list(axes_args.keys())):
            models[arg] = np.array([v for _ in grid])
    # add extra variables
    for arg in exclude_args:
        if (arg in saved_args.keys()
            and arg not in drop_args):
            models[arg] = saved_args[arg]
    return models

# %% ../nbs/utils.ipynb 18
def multi(dispatch_fn):
    def _inner(*args, **kwargs):
        return _inner.__multi__.get(
            dispatch_fn(*args, **kwargs),
            _inner.__multi_default__
        )(*args, **kwargs)
    
    _inner.__dispatch_fn__ = dispatch_fn
    _inner.__multi__ = {}
    _inner.__multi_default__ = lambda *args, **kwargs: None  # Default default
    return _inner

# %% ../nbs/utils.ipynb 19
def method(dispatch_fn, dispatch_key=None):
    def apply_decorator(fn):
        if dispatch_key is None:
            # Default case
            dispatch_fn.__multi_default__ = fn
        else:
            dispatch_fn.__multi__[dispatch_key] = fn
        return dispatch_fn
    return apply_decorator

# %% ../nbs/utils.ipynb 21
@multi
def area(shape):
    return shape.get('type')

@method(area, 'square')
def area(square):
    return square['width'] * square['height']

@method(area, 'circle')
def area(circle):
    return circle['radius'] ** 2 * 3.14159

@method(area)
def area(unknown_shape):
    raise Exception("Can't calculate the area of this shape")

# %% ../nbs/utils.ipynb 22
fastcore.test.test_eq(area({'type': 'square', 'width': 1, 'height': 1}), 1)
fastcore.test.test_close(area({'type': 'circle', 'radius': 0.5}), 0.7853975)
with fastcore.test.ExceptionExpected():
    area({'type': 'rhombus'})
