# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_methods.ipynb.

# %% auto 0
__all__ = ['T_type', 'fermi_learning', 'fixation_rate', 'ModelTypeEGT', 'build_transition_matrix', 'find_ergodic_distribution',
           'markov_chain']

# %% ../nbs/01_methods.ipynb 1
from nbdev.showdoc import *
import fastcore.test
from .utils import *
from .types import *
import typing

import numpy as np
import nptyping

# %% ../nbs/01_methods.ipynb 9
def fermi_learning(β:nptyping.NDArray, # learning rate
                   fitnessA:nptyping.NDArray, # fitness of strategy A
                   fitnessB:nptyping.NDArray # fitness of strategy B
                  ) -> nptyping.NDArray:
    """Compute the likelihood that a player with strategy B adopts strategy A using the fermi function."""
    return (1 + np.exp(-β*(fitnessA - fitnessB)))**-1

# %% ../nbs/01_methods.ipynb 17
T_type = list[nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]]

def fixation_rate(Tplus: T_type, # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of gaining one mutant
                  Tneg: T_type, # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of losing one mutant
                 ) -> nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]: # Fixation rates for the given strategy in each model
    """Calculate the likelihood that a mutant invades the population."""
    Z = len(Tplus) + 1
    ρ = (np.sum([np.prod([Tneg[j-1]/Tplus[j-1]
                         for j in range(1,i+1)],
                        axis=0,
                        keepdims=False)
                 for i in range(1,Z)],
                axis=0,
                keepdims=False)
        + 1)**-1
    return ρ

# %% ../nbs/01_methods.ipynb 39
class ModelTypeEGT():
    """This is the schema for an Evolutionary Game Theory model.
    
    Note: This schema is not enforced and is here purely for documentation
    purposes."""
    def __init__(self, 
                 Z: int, # the size of the population
                 strategy_set: list[str], # the set of strategies in the model
                 β: Array1D, # the learning rate
                 payoffs: Array3D, # the payoffs of the game
                 transition_matrix: Array3D=None, # the model's transition matrix
                 ergodic: Array2D=None, # ergodic distribution of the model's markov chain
                ):
        pass

# %% ../nbs/01_methods.ipynb 41
def build_transition_matrix(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                           ):
    """Build a transition matrix between all monomorphic states
    using the fermi social learning rule for each model.    
    """
    
    Z, S, β = [models[k] for k in ['Z','strategy_set', 'β']]
    π = models['payoffs']
    n_models = π.shape[0]
    M = np.zeros(( n_models, len(S), len(S)))
    for row_ind, s in enumerate(S):
        for col_ind, sₒ in enumerate(S):
            if row_ind == col_ind:
                # We compute these entries later
                continue
            πAA = π[:, row_ind, row_ind]
            πAB = π[:, row_ind, col_ind]
            πBA = π[:, col_ind, row_ind]
            πBB = π[:, col_ind, col_ind]
            ΠA = [πAA*(k-1)/(Z-1) + πAB*(Z-k)/(Z-1)
                  for k in range(1, Z)]
            ΠB = [πBA*k/(Z-1)  + πBB*(Z-k-1)/(Z-1)
                  for k in range(1, Z)]
            # For numerical stability we ignore the k/Z and (Z-k)/k factors
            # in Tplus and Tneg since they cancel out when fermi_learning
            # takes their ratio
            Tplus = [fermi_learning(β, ΠB[k-1], ΠA[k-1])
                     for k in range(1, Z)]
            Tneg = [fermi_learning(β, ΠA[k-1], ΠB[k-1])
                    for k in range(1, Z)]
            # This is the probability that B successfully invades A
            ρ = fixation_rate(Tplus, Tneg)
            M[:, row_ind, col_ind] = ρ / max(1, len(S)-1)
    for row_ind in range(len(S)):
        col_inds = [i for i in range(len(S)) if i != row_ind]
        no_move = 1 - np.sum(M[:, row_ind, col_inds], axis=1)
        M[:, row_ind, row_ind] = no_move
    return {**models, "transition_matrix": M}

# %% ../nbs/01_methods.ipynb 54
def find_ergodic_distribution(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                             ):
    """Find the ergodic distribution of a markov chain with the
    given transition matrix."""
    
    M = models["transition_matrix"]
    # find unit eigenvector of markov chain
    Λ,V = np.linalg.eig(M.transpose(0,2,1))
    x = np.isclose(Λ, 1)
    # if multiple unit eigenvalues then choose the first
    y = np.zeros_like(x, dtype=bool)
    idx = np.arange(len(x)), x.argmax(axis=1)
    y[idx] = x[idx]
    ergodic = np.array(V.transpose(0,2,1)[y], dtype=float)
    # ensure ergodic frequencies are positive and sum to 1
    ergodic = np.abs(ergodic) / np.sum(np.abs(ergodic), axis=1)[:, None]
    return {**models, 'ergodic':ergodic}

# %% ../nbs/01_methods.ipynb 65
def markov_chain(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                ):
    """Find the ergodic distribution of the evolutionary
    game given by each model in models."""
    return thread_macro(models,
                        build_transition_matrix,
                        find_ergodic_distribution)
