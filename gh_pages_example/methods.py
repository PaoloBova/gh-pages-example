# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_methods.ipynb.

# %% auto 0
__all__ = ['T_type', 'fermi_learning', 'fixation_rate', 'build_transition_matrix', 'find_ergodic_distribution', 'markov_chain']

# %% ../nbs/01_methods.ipynb 1
from nbdev.showdoc import *
from fastcore.test import test_eq
from .utils import *
import typing

import numpy as np
import nptyping

# %% ../nbs/01_methods.ipynb 9
def fermi_learning(β:nptyping.NDArray, # learning rate
                   fitnessA:nptyping.NDArray, # fitness of strategy A
                   fitnessB:nptyping.NDArray # fitness of strategy B
                  ) -> nptyping.NDArray:
    """Compute the likelihood that a player with strategy B adopts strategy A using the fermi function."""
    return (1 + np.exp(-β*(fitnessA - fitnessB)))**-1

# %% ../nbs/01_methods.ipynb 17
T_type = list[nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]]

def fixation_rate(Tplus: T_type, # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of gaining one mutant
                  Tneg: T_type, # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of losing one mutant
                 ) -> nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]: # Fixation rates for the given strategy in each model
    """Calculate the likelihood that a mutant invades the population."""
    Z = len(Tplus) - 1
    ρ = (np.sum([np.prod([Tneg[j]/Tplus[j]
                         for j in range(1,i+1)],
                        axis=0,
                        keepdims=False)
                 for i in range(1,Z)],
                axis=0,
                keepdims=False)
        + 1)**-1
    return ρ

# %% ../nbs/01_methods.ipynb 36
def build_transition_matrix(models:dict # A dictionary containing EGT models stacked as arrays
                           ):
    """Build a transition matrix between all monomorphic states
    using the fermi social learning rule for each model.    
    """
    
    Z, S, β = [models[k] for k in ['Z','strategy_set', 'β']]
    π = models['payoffs']
    n_models = π.shape[0]
    M = np.zeros(( n_models, len(S), len(S)))
    for row_ind, s in enumerate(S):
        for col_ind, sₒ in enumerate(S):
            if row_ind == col_ind:
                # We compute these entries later
                continue
            πAA = π[:, row_ind, row_ind]
            πAB = π[:, row_ind, col_ind]
            πBA = π[:, col_ind, row_ind]
            πBB = π[:, col_ind, col_ind]
            ΠA = [πAA*(k-1)/Z + πAB*(Z-k)/Z
                  for k in range(Z+1)]
            ΠB = [πBA*k/Z + πBB*(Z-k-1)/Z
                  for k in range(Z+1)]
            Tplus = [(Z - k)/Z
                     * k/Z
                     * fermi_learning(β, ΠA[k], ΠB[k])
                     for k in range(Z+1)]
            Tneg = [(Z - k)/Z
                    * k/Z
                    * fermi_learning(β, ΠB[k], ΠA[k])
                    for k in range(Z+1)]
            ρ = fixation_rate(Tplus, Tneg)
            M[:, col_ind, row_ind] = ρ / max(1, len(S)-1)
    for row_ind in range(len(S)):
        col_inds = [i for i in range(len(S)) if i != row_ind]
        no_move = 1 - np.sum(M[:, row_ind, col_inds], axis=1)
        M[:, row_ind, row_ind] = no_move
    return {**models, "transition_matrix": M}

# %% ../nbs/01_methods.ipynb 39
def find_ergodic_distribution(models):
    """Find the ergodic distribution of a markov chain with the
    given transition matrix."""
    
    M = models.get("transition_matrix", np.zeros((1, 1, 1)))
    # find unit eigenvector of markov chain
    Λ,V = np.linalg.eig(M.transpose(0,2,1))
    x = np.isclose(Λ, 1)
    # if multiple unit eigenvalues then choose the first
    y = np.zeros_like(x, dtype=bool)
    idx = np.arange(len(x)), x.argmax(axis=1)
    y[idx] = x[idx]
    ergodic = np.array(V.transpose(0,2,1)[y], dtype=float)
    # ensure ergodic frequencies are positive and sum to 1
    ergodic = np.abs(ergodic) / np.sum(np.abs(ergodic), axis=1)[:, None]
    return {**models, 'ergodic':ergodic}

# %% ../nbs/01_methods.ipynb 41
def markov_chain(models):
    """Find the ergodic distribution of the evolutionary
    game given by each model in models."""
    return thread_macro(models,
                        build_transition_matrix,
                        find_ergodic_distribution)
