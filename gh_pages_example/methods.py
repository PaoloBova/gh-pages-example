# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_methods.ipynb.

# %% auto 0
__all__ = ['T_type', 'result', 'allowed_sectors', 'sector_strategies', 'n_players', 'n_strategies', 'models', 'expected',
           'transition_indices', 'result1', 'result2', 'fermi_learning', 'fixation_rate', 'fixation_rate_stable',
           'ModelTypeEGT', 'build_transition_matrix', 'find_ergodic_distribution', 'markov_chain',
           'create_all_profiles', 'profile_filter', 'valid_transition']

# %% ../nbs/01_methods.ipynb 1
from .utils import *
from .types import *

import functools
import typing

import fastcore.test
from nbdev.showdoc import *
import numpy as np
import nptyping

# %% ../nbs/01_methods.ipynb 10
def fermi_learning(fitnessA:nptyping.NDArray, # fitness of strategy A
                   fitnessB:nptyping.NDArray, # fitness of strategy B
                   β:nptyping.NDArray, # learning rate
                  ) -> nptyping.NDArray:
    """Compute the likelihood that a player with strategy A adopts strategy B using the fermi function."""
    return (1 + np.exp(-β*(fitnessB - fitnessA)))**(-1)

# %% ../nbs/01_methods.ipynb 19
T_type = list[nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]]

def fixation_rate(Tplus: T_type, # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of gaining one mutant
                  Tneg: T_type, # A list of NDarrays, one array (of size n_models) for each possible number of mutants in the population; the probability of losing one mutant
                 ) -> nptyping.NDArray[nptyping.Shape["N_models"], typing.Any]: # Fixation rates for the given strategy in each model
    """Calculate the likelihood that a mutant invades the population."""
    Z = len(Tplus) + 1
    ρ = (np.sum([np.prod([Tneg[j-1]/Tplus[j-1]
                         for j in range(1,i+1)],
                        axis=0,
                        keepdims=False)
                 for i in range(1,Z)],
                axis=0,
                keepdims=False)
        + 1)**-1
    return ρ

# %% ../nbs/01_methods.ipynb 40
def fixation_rate_stable(ΠA:list, # Average payoffs for the strategy A they consider adopting for each number of mutants following A
                         ΠB:list, # Average payoffs for the strategy B that the player currently follows for each number of mutants following A
                         β:Array1D, # learning rate 
                        ):
    """Calculate the likelihood that a mutant B invades population A
    using a numerically stable method."""
    fastcore.test.test_eq(len(ΠA), len(ΠB))
    Z = len(ΠA) + 1
    ρ = (np.sum([np.exp(np.clip(np.sum([-β*(ΠB[j-1] - ΠA[j-1])
                                        for j in range(1,i+1)],
                                       axis=0,
                                       keepdims=False),
                                -500,
                                500)) # avoid underflow/overflow warnings
                 for i in range(1,Z)],
                axis=0,
                keepdims=False)
        + 1)**-1
    return ρ

# %% ../nbs/01_methods.ipynb 55
class ModelTypeEGT():
    """This is the schema for an Evolutionary Game Theory model.
    
    Note: This schema is not enforced and is here purely for documentation
    purposes."""
    def __init__(self, 
                 Z: int, # the size of the population
                 strategy_set: list[str], # the set of strategies in the model
                 β: Array1D, # the learning rate
                 payoffs: Array3D, # the payoffs of the game
                 transition_matrix: Array3D=None, # the model's transition matrix
                 ergodic: Array2D=None, # ergodic distribution of the model's markov chain
                ):
        pass

# %% ../nbs/01_methods.ipynb 57
@multi
def build_transition_matrix(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                           ):
    """Build a transition matrix between all monomorphic states using the
    fermi social learning rule."""
    return models.get('dispatch-type')
    

@method(build_transition_matrix)
def build_transition_matrix(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                           ):
    """Build a transition matrix between all monomorphic states
    using the fermi social learning rule for each model.    
    """
    
    Z, S, β = [models[k] for k in ['Z','strategy_set', 'β']]
    π = models['payoffs']
    n_models = π.shape[0]
    M = np.zeros(( n_models, len(S), len(S)))
    for row_ind, s in enumerate(S):
        for col_ind, sₒ in enumerate(S):
            if row_ind == col_ind:
                M[:, row_ind, row_ind] += 1
                # We calibrate these entries later so rows add up to 1
                continue
            πAA = π[:, row_ind, row_ind]
            πAB = π[:, row_ind, col_ind]
            πBA = π[:, col_ind, row_ind]
            πBB = π[:, col_ind, col_ind]
            ΠA = [πAA*(Z-k-1)/(Z-1) + πAB*k/(Z-1)
                  for k in range(1, Z)]
            ΠB = [πBA*(Z-k)/(Z-1)  + πBB*(k-1)/(Z-1)
                  for k in range(1, Z)]
            # We use a numerically stable method to find the fixation rate, ρ.
            # ρ is the probability that mutant B successfully invades A
            ρ = fixation_rate_stable(ΠA, ΠB, β)
            M[:, row_ind, col_ind] = ρ / max(1, len(S)-1)
            M[:, row_ind, row_ind] -= ρ / max(1, len(S)-1)
    return {**models, "transition_matrix": M}

# %% ../nbs/01_methods.ipynb 58
@method(build_transition_matrix, 'unstable')
def build_transition_matrix(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                           ):
    """Build a transition matrix using a numerically unstable method."""
    
    Z, S, β = [models[k] for k in ['Z','strategy_set', 'β']]
    π = models['payoffs']
    n_models = π.shape[0]
    M = np.zeros(( n_models, len(S), len(S)))
    for row_ind, s in enumerate(S):
        for col_ind, sₒ in enumerate(S):
            if row_ind == col_ind:
                M[:, row_ind, row_ind] += 1
                # We calibrate these entries later so rows add up to 1
                continue
            πAA = π[:, row_ind, row_ind]
            πAB = π[:, row_ind, col_ind]
            πBA = π[:, col_ind, row_ind]
            πBB = π[:, col_ind, col_ind]
            ΠA = [πAA*(Z-k-1)/(Z-1) + πAB*k/(Z-1)
                  for k in range(1, Z)]
            ΠB = [πBA*(Z-k)/(Z-1)  + πBB*(k-1)/(Z-1)
                  for k in range(1, Z)]
            Tneg = [fermi_learning(ΠB[k-1], ΠA[k-1], β)
                    for k in range(1, Z)]
            Tplus = [fermi_learning(ΠA[k-1], ΠB[k-1], β)
                     for k in range(1, Z)]
            ρ = fixation_rate(Tplus, Tneg)
            M[:, row_ind, col_ind] = ρ / max(1, len(S)-1)
            M[:, row_ind, row_ind] -= ρ / max(1, len(S)-1)
    return {**models, "transition_matrix": M}

# %% ../nbs/01_methods.ipynb 79
def find_ergodic_distribution(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                             ):
    """Find the ergodic distribution of a markov chain with the
    given transition matrix."""
    M = models["transition_matrix"]
    # find unit eigenvector of markov chain
    Λ,V = np.linalg.eig(M.transpose(0,2,1))
    V = np.real_if_close(V)
    x = np.isclose(Λ, 1)
    # if multiple unit eigenvalues then choose the first
    y = np.zeros_like(x, dtype=bool)
    idx = np.arange(len(x)), x.argmax(axis=1)
    y[idx] = x[idx]
    ergodic = np.array(V.transpose(0,2,1)[y], dtype=float)
    # ensure ergodic frequencies are positive and sum to 1
    ergodic = np.abs(ergodic) / np.sum(np.abs(ergodic), axis=1)[:, None]
    return {**models, 'ergodic':ergodic}

# %% ../nbs/01_methods.ipynb 91
def markov_chain(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                ):
    """Find the ergodic distribution of the evolutionary
    game given by each model in models."""
    return thread_macro(models,
                        build_transition_matrix,
                        find_ergodic_distribution)

# %% ../nbs/01_methods.ipynb 94
@method(build_transition_matrix, 'multiple-populations')
def build_transition_matrix(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                           ):
    """Build a transition matrix between all monomorphic states
    when there are multiple populations.    
    """
    Z, S, β = [models[k] for k in ['Z', 'recurrent_state_space', 'β']]
    valid_transitions = models['valid_transitions']
    π = models['payoffs']
    M = np.zeros((payoffs.shape[0], len(S), len(S)))
    for row_ind in range(M.shape[-1]):
        M[:, row_ind, row_ind] += 1
    for transition in valid_transitions.values():
        strategy_profile_indices = transition['strategy_profile_indices']
        player_index = transition['player_index']
        row_ind = transition['row_ind']
        col_ind = transition['col_ind']
        πAA = π[:, strategy_profile_indices['AA'], player_index]
        πAB = π[:, strategy_profile_indices['AB'], player_index]
        πBA = π[:, strategy_profile_indices['BA'], player_index]
        πBB = π[:, strategy_profile_indices['BB'], player_index]
        ΠA = [πAA*(Z-k-1)/(Z-1) + πAB*k/(Z-1)
              for k in range(1, Z)]
        ΠB = [πBA*(Z-k)/(Z-1)  + πBB*(k-1)/(Z-1)
              for k in range(1, Z)]
        # We use a numerically stable method to find the fixation rate, ρ.
        # ρ is the probability that mutant B successfully invades A
        ρ = fixation_rate_stable(ΠA, ΠB, β)
        # We have to divide this rate by the number of possible mutations
        n_mutations = 0
        for vt in valid_transitions.values():
            if vt['row_ind'] == row_ind:
                n_mutations += 1
        M[:, row_ind, col_ind] = ρ / n_mutations
        M[:, row_ind, row_ind] -= ρ / n_mutations
    return {**models, 'transition_matrix':M}

# %% ../nbs/01_methods.ipynb 111
def create_all_profiles(models):
    """Create all strategy profiles for the set of models."""
    n_players, n_strategies = [models[k] for k in ['n_players', 'n_strategies']]
    n_strategies_total = np.sum(n_strategies)
    n_profiles = n_strategies_total ** n_players
    strategy_axis = np.arange(n_strategies_total)[:, None]
    grid = build_grid_from_axes([strategy_axis for _ in range(n_players)])
    profiles = []
    for row in grid:
        profile = "-".join(map(str, row))
        profiles.append(profile)
    fastcore.test.test_eq(len(profiles), n_profiles)
    return {**models, "profiles": profiles}

# %% ../nbs/01_methods.ipynb 113
result = create_all_profiles({"n_players": 2, "n_strategies": 2})
fastcore.test.test_eq(result['profiles'], ["0-0", "0-1", "1-0", "1-1"])

result = create_all_profiles({"n_players": 2, "n_strategies": [2, 2]})
fastcore.test.test_eq(result['profiles'],
                       ["0-0", "0-1", "0-2", "0-3",
                        "1-0", "1-1", "1-2", "1-3",
                        "2-0", "2-1", "2-2", "2-3",
                        "3-0", "3-1", "3-2", "3-3",])

fastcore.test.test_eq(create_all_profiles({"n_players": 2,
                                           "n_strategies": [2, 2]})['profiles'],
                     create_all_profiles({"n_players": 2,
                                          "n_strategies": 4})['profiles'])

# %% ../nbs/01_methods.ipynb 114
@multi
def profile_filter(models):
    "Filter strategy profiles to those which satisfy the given rule."
    return models.get('profile_filter_rule')

@method(profile_filter, 'allowed_sectors')
def profile_filter(models):
    """Filter strategy profiles to only those where players are from their
    allowed sectors."""
    profiles = models.get('profiles_filtered',
                          models.get('profiles',
                                     create_all_profiles(models)['profiles']))
    allowed_sectors = models['allowed_sectors']
    sector_strategies = models['sector_strategies']
    profiles_filtered = []
    for k in profiles:
        k_tuple = list(map(int, k.split("-")))
        valid = True
        for i, ind in enumerate(k_tuple[::-1]):
            allowed_inds = np.hstack([sector_strategies[j]
                                      for j in allowed_sectors[f"P{i+1}"]])
            if ind not in allowed_inds:
                valid = False
        if valid==True:
            profiles_filtered.append(k)
    return {**models, "profiles_filtered": profiles_filtered}

@method(profile_filter)
def profile_filter(models):
    """The default filter method leaves models unchanged."""
    print("""`profile_filter` called but `models` did not specify a
           `profile_filter_rule`. Try specifying one.""")
    return models

# %% ../nbs/01_methods.ipynb 117
@method(profile_filter, 'relevant_to_transition')
def profile_filter(models):
    """Filter for strategy profiles relevant to the given transition."""
    ind1, ind2 = models['transition_indices']
    sector_strategies = models['sector_strategies']
    profiles = models.get('profiles_filtered',
                          models.get('profiles',
                                     create_all_profiles(models)['profiles']))
    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1!=i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    valid = sum(differ) == 1
    if valid:
        affected_sector = f"S{np.argmax(differ[::-1]) + 1}"
        flexible_strategies = sector_strategies[affected_sector]
        strategies1 = [sector_strategies[f"S{i+1}"][ind]
                             for i, ind in enumerate(ind1_tuple[::-1])]
        strategies2 = [sector_strategies[f"S{i+1}"][ind]
                       for i, ind in enumerate(ind2_tuple[::-1])]
        strategies_valid = np.unique(np.hstack([strategies1, strategies2]))
        profiles_filtered = []
        for profile in profiles:
            relevant = True
            for strategy in list(map(int, profile.split("-"))):
                if strategy not in strategies_valid:
                    relevant = False
            if relevant == True:
                profiles_filtered.append(profile)
        relevant = True
        return {**models, "profiles_filtered": profiles_filtered}
    return models

# %% ../nbs/01_methods.ipynb 121
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
sector_strategies = {"S2": [2, 3],
                     "S1": [0, 1]}
n_players = 3
n_strategies = [2, 2] # this could be derived from sector_strategies or the other way round.
models = {"profile_filter_rule": "allowed_sectors",
          "n_players": n_players,
          "n_strategies": n_strategies,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies}
result = profile_filter(models)['profiles_filtered']
# Only strategy 2 is irrelevant
expected = ["2-2-0", "2-2-1", 
            "2-3-0", "2-3-1",
            "3-2-0", "3-2-1",
            "3-3-0", "3-3-1",]
fastcore.test.test_eq(result, expected)
fastcore.test.test_eq(len(result), 8)

# %% ../nbs/01_methods.ipynb 123
allowed_sectors = {"P3": ["S3"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
sector_strategies = {"S3": [4, 5],
                     "S2": [2, 3],
                     "S1": [0, 1]}
models = {"profile_filter_rule": "allowed_sectors",
          "n_players": 3,
          "n_strategies": [2, 2, 2],
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies}
result = profile_filter(models)['profiles_filtered']
expected = ["4-2-0",
            "4-2-1",
            "4-3-0",
            "4-3-1",
            "5-2-0",
            "5-2-1",
            "5-3-0",
            "5-3-1",
           ]
fastcore.test.test_eq(result, expected)

# %% ../nbs/01_methods.ipynb 126
sector_strategies = {"S2": [2, 3],
                     "S1": [0, 1]}
transition_indices = ["1-0", "1-1"]
n_players = 3
n_strategies = [2, 2] # this could be derived from sector_strategies or the other way round.
models = {"profile_filter_rule": "relevant_to_transition",
          "n_players": n_players,
          "n_strategies": n_strategies,
          "sector_strategies": sector_strategies,
          "transition_indices": transition_indices}
result = profile_filter(models)['profiles_filtered']
# Only strategy 2 is irrelevant
expected = ["0-0-0", "0-0-1", "0-0-3", 
            "0-1-0", "0-1-1", "0-1-3",
            "0-3-0", "0-3-1", "0-3-3",
            "1-0-0", "1-0-1", "1-0-3",
            "1-1-0", "1-1-1", "1-1-3",
            "1-3-0", "1-3-1", "1-3-3",
            "3-0-0", "3-0-1", "3-0-3",
            "3-1-0", "3-1-1", "3-1-3",
            "3-3-0", "3-3-1", "3-3-3"]
fastcore.test.test_eq(result, expected)
expected = (np.sum(n_strategies) - 1) ** n_players  # 1 of the 4 strategies won't be relevant here
fastcore.test.test_eq(len(result), expected)

# %% ../nbs/01_methods.ipynb 128
sector_strategies = {"S3": [4, 5],
                     "S2": [2, 3],
                     "S1": [0, 1]}
transition_indices = ["1-1-1", "1-1-0"]
n_players = 3
n_strategies = [2, 2, 2]
models = {"profile_filter_rule": "relevant_to_transition",
          "n_players": n_players,
          "n_strategies": n_strategies,
          "sector_strategies": sector_strategies,
          "transition_indices": transition_indices}
result = profile_filter(models)['profiles_filtered']
expected = (np.sum(n_strategies) - 2) ** n_players  # 2 of the 6 strategies won't be relevant here
fastcore.test.test_eq(len(result), expected)

# %% ../nbs/01_methods.ipynb 130
allowed_sectors = {"P3": ["S3"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
sector_strategies = {"S3": [4, 5],
                     "S2": [2, 3],
                     "S1": [0, 1]}
transition_indices = ["1-1-1", "1-1-0"]
n_players = 3
n_strategies = [2, 2, 2]
models = {"profile_filter_rule": "relevant_to_transition",
          "n_players": n_players,
          "n_strategies": n_strategies,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          "transition_indices": transition_indices}
result = thread_macro(models,
                      profile_filter,
                      (assoc, "profile_filter_rule", "allowed_sectors"),
                      profile_filter)
expected = ["5-3-0", "5-3-1"]
fastcore.test.test_eq(len(result['profiles_filtered']), 2)
fastcore.test.test_eq(result['profiles_filtered'], expected)

# %% ../nbs/01_methods.ipynb 132
allowed_sectors = {"P3": ["S3"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
sector_strategies = {"S3": [4, 5],
                     "S2": [2, 3],
                     "S1": [0, 1]}
transition_indices = ["1-1-1", "1-1-0"]
n_players = 3
n_strategies = [2, 2, 2]
models = {"profile_filter_rule": "relevant_to_transition",
          "n_players": n_players,
          "n_strategies": n_strategies,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          "transition_indices": transition_indices}
result1 = thread_macro(models,
                       profile_filter,
                       (assoc, "profile_filter_rule", "allowed_sectors"),
                       profile_filter)
result2 = thread_macro(models,
                       (assoc, "profile_filter_rule", "allowed_sectors"),
                       profile_filter,
                       (assoc, "profile_filter_rule", "relevant_to_transition"),
                       profile_filter)
expected = ["5-3-0", "5-3-1"]
fastcore.test.test_eq(result1['profiles_filtered'], expected)
fastcore.test.test_eq(result2['profiles_filtered'], expected)
fastcore.test.test_eq(result1['profiles_filtered'],
                      result2['profiles_filtered'])

# %% ../nbs/01_methods.ipynb 134
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
sector_strategies = {"S2": [2, 3],
                     "S1": [0, 1]}
transition_indices = ["1-0", "1-1"]
n_players = 3
n_strategies = [2, 2] # this could be derived from sector_strategies or the other way round.
models = {"profile_filter_rule": "relevant_to_transition",
          "n_players": n_players,
          "n_strategies": n_strategies,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          "transition_indices": transition_indices}
result1 = thread_macro(models,
                       profile_filter,
                       (assoc, "profile_filter_rule", "allowed_sectors"),
                       profile_filter)
result2 = thread_macro(models,
                       (assoc, "profile_filter_rule", "allowed_sectors"),
                       profile_filter,
                       (assoc, "profile_filter_rule", "relevant_to_transition"),
                       profile_filter)
expected = ["3-3-0", "3-3-1"]
fastcore.test.test_eq(result1['profiles_filtered'], expected)
fastcore.test.test_eq(result2['profiles_filtered'], expected)
fastcore.test.test_eq(result1['profiles_filtered'],
                      result2['profiles_filtered'])

# %% ../nbs/01_methods.ipynb 136
allowed_sectors = {"P3": ["S2"],
                   "P2": ["S2"],
                   "P1": ["S1"]}
sector_strategies = {"S2": [2, 3],
                     "S1": [0, 1]}
transition_indices = ["0-1", "1-1"]
n_players = 3
n_strategies = [2, 2] # this could be derived from sector_strategies or the other way round.
models = {"profile_filter_rule": "relevant_to_transition",
          "n_players": n_players,
          "n_strategies": n_strategies,
          "allowed_sectors": allowed_sectors,
          "sector_strategies": sector_strategies,
          "transition_indices": transition_indices}
result1 = thread_macro(models,
                       profile_filter,
                       (assoc, "profile_filter_rule", "allowed_sectors"),
                       profile_filter)
result2 = thread_macro(models,
                       (assoc, "profile_filter_rule", "allowed_sectors"),
                       profile_filter,
                       (assoc, "profile_filter_rule", "relevant_to_transition"),
                       profile_filter)
expected = ["2-2-1", "2-3-1", "3-2-1", "3-3-1"]
fastcore.test.test_eq(result1['profiles_filtered'], expected)
fastcore.test.test_eq(result2['profiles_filtered'], expected)
fastcore.test.test_eq(result1['profiles_filtered'],
                      result2['profiles_filtered'])

# %% ../nbs/01_methods.ipynb 138
def valid_transition(ind1:str, # The index of the current state, expressed in the form "{strategy_code}-{strategy_code}-{strategy_code}"
                     ind2:str,  # The index of the next state, expressed in the same form as `ind1`
                    ) -> bool: # True if the transition is valid, false otherwise
    """Check if the transition from ind1->ind2 is valid
    i.e. that only one population undergoes a change in strategy."""
    ind1_tuple = list(map(int, ind1.split("-")))
    ind2_tuple = list(map(int, ind2.split("-")))
    differ = [i1!=i2 for i1, i2 in zip(ind1_tuple, ind2_tuple)]
    valid = sum(differ) == 1
    return valid

# %% ../nbs/01_methods.ipynb 140
fastcore.test.test_eq(valid_transition("1-1-1", "2-1-1"), True)
fastcore.test.test_eq(valid_transition("1-1-1", "2-1-2"), False)
fastcore.test.test_eq(valid_transition("1-1-1", "0-0-0"), False)
fastcore.test.test_eq(valid_transition("1-1-1", "22-1-3"), False)
fastcore.test.test_eq(valid_transition("1-1-1", "1-1-1"), False) # Even though possible, self transitions are marked as false since we never compute them directly

# %% ../nbs/01_methods.ipynb 143
@method(build_transition_matrix, 'multiple-populations-v2')
def build_transition_matrix(models:dict # A dictionary that contains the parameters in `ModelTypeEGT`
                           ):
    """Build a transition matrix between all monomorphic states
    when there are multiple populations.    
    """
    Z, S, β = [models[k] for k in ['Z', 'recurrent_state_space', 'β']]
    π = models['payoffs']
    compute_success_fn = models['compute_success_fn']
    M = np.zeros((payoffs.shape[0], len(S), len(S)))
    for row_ind in range(M.shape[-1]):
        M[:, row_ind, row_ind] += 1
    transitions = [(i, j) for i in range(len(S)) for j in range(len(S))]
    for row_ind, col_ind in transitions:
        current_state, new_state = S[row_ind], S[col_ind]
        if current_state == new_state:
            continue
        if not valid_transition(current_state, new_state):
            continue
        relevant_profiles = thread_macro(models,
                                         (assoc, "profile_filter_rule",
                                                 "relevant_to_transition"),
                                         profile_filter,
                                         (assoc, "profile_filter_rule",
                                                 "allowed_sectors"),
                                         profile_filter,
                                         (get, "profiles_filtered"),
                                        )
        ΠA, ΠB = compute_success_fn({**models,
                                     "relevant_profiles": relevant_profiles})
        ρ = fixation_rate_stable(ΠA, ΠB, β)
        n_mutations = sum(valid_transition(current_state, possible state)
                          for possible_state in S)
        M[:, row_ind, col_ind] = ρ / n_mutations
        M[:, row_ind, row_ind] -= ρ / n_mutations
    return {**models, 'transition_matrix':M}
