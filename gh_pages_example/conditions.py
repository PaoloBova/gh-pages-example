# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_analytical_conditions.ipynb.

# %% auto 0
__all__ = ['threshold_society_prefers_safety_dsair', 'threshold_risk_dominant_safety_dsair',
           'threshold_risk_dominant_safety_reg_market', 'threshold_ps_r_d_au']

# %% ../nbs/03_analytical_conditions.ipynb 2
from nbdev.showdoc import *
from fastcore.test import test_eq
from .utils import *
from .payoffs import *
import typing


import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import nptyping

# %% ../nbs/03_analytical_conditions.ipynb 6
def threshold_society_prefers_safety_dsair(models):
    """The threhsold value of AI risk for which society prefers firms to be
    Always Safe in the DSAIR model."""
    s, B, W = [models[k]
               for k in ['s', 'B', 'W']]
    πAA, πAB, πBA, πBB = [models['payoffs_sr'][:, i, j]
                          for i in range(2) for j in range(2)]
    p_risk = 1 - ((πAA + B / (2 * W))
                  / (πBB + s * B / (2 * W)))
    return {**models, "threshold_society_prefers_safety": p_risk}

# %% ../nbs/03_analytical_conditions.ipynb 9
def threshold_risk_dominant_safety_dsair(models):
    """The threshold value of AI risk for which Always Safe is risk dominant
    against Always Unsafe in the DSAIR model."""
    s, B, W = [models[k]
               for k in ['s', 'B', 'W']]
    πAA, πAB, πBA, πBB = [models['payoffs_sr'][:, i, j]
                          for i in range(2) for j in range(2)]
    p_risk = 1 - ((πAA + πAB + B / (2 * W))
                  / (πBA + πBB + 3 * s * B / (2 * W)))
    return {**models, "threshold_risk_dominant_safety": p_risk}

# %% ../nbs/03_analytical_conditions.ipynb 10
def threshold_risk_dominant_safety_reg_market(models):
    """The threshold value of AI risk for which Always Safe is risk dominant
    against Always Unsafe in the Regulatory Market model when the detection risk
    is fixed."""
    s, B, W = [models[k]
               for k in ['s', 'B', 'W']]
    πAA, πAB, πBA, πBB = [models['payoffs_sr'][:, i, j]
                          for i in range(2) for j in range(2)]
    p_risk = 1 - ((πAA + πAB + B / (2 * W))
                  / (πBA + πBB + 3 * s * B / (2 * W)))
    return {**models, "threshold_risk_dominant_safety": p_risk}

# %% ../nbs/03_analytical_conditions.ipynb 12
def threshold_ps_r_d_au(models):
    """The analytic threshold for when strategy PS risk dominates AU
    in a DSAIR model with peer punishment, expressed in terms of p_risk"""
    s,b,c, B, W, pfo = [models[k]
                      for k in ['s', 'b', 'c', 'B', 'W', 'pfo']]
    α, γ = [models[k] for k in ['α', 'γ']]
    πAA,πAB,πBA,πBB = [models['payoffs_sr'][:, i, j]
                       for i in range(2) for j in range(2)]
    
    s_punished = s - γ
    s_sanctioner = 1 - α
    sum_of_speeds = np.maximum(1e-20, s_punished + s_sanctioner)
    punished_wins = (s_punished > 0) & (((W-s)*np.maximum(0, s_sanctioner))
                                        <= ((W-1) * s_punished))
    punished_draws = (s_punished > 0) & (((W-s) * s_sanctioner)
                                         == ((W-1) * s_punished))
    sanctioner_wins = (s_sanctioner > 0) & (((W-s) * s_sanctioner)
                                            >= ((W-1)*np.maximum(0,s_punished)))
    no_winner = (s_punished <= 0) & (s_sanctioner <= 0)

    both_speeds_positive = (s_punished > 0) & (s_sanctioner > 0)
    only_sanctioner_speed_positive = (s_punished <= 0) & (s_sanctioner > 0)
    only_punisher_speed_positive = (s_punished > 0) & (s_sanctioner <= 0)

    R = np.where(no_winner,
                 1e50,
                 1 + np.minimum((W-s)/ np.maximum(s_punished, 1e-10),
                                (W-1)/ np.maximum(s_sanctioner, 1e-10)))
    B_s = np.where(sanctioner_wins, B, np.where(punished_draws, B/2, 0))
    B_p = np.where(punished_wins, B, np.where(punished_draws, B/2, 0))
    b_s = np.where(both_speeds_positive,
                   (1-pfo) * b * s_sanctioner / sum_of_speeds + pfo * b,
                   np.where(only_sanctioner_speed_positive, b, 0))
    b_p = np.where(both_speeds_positive,
                   (1-pfo) * b * s_punished / sum_of_speeds,
                   np.where(only_punisher_speed_positive, (1 - pfo)*b, 0))

    sanctioner_payoff = (1 / R) * (πAB + B_s + (R-1)*(b_s - c))
    punished_payoff_without_ploss = (1 / R) * (πBA + B_p + (R-1)*b_p)
    
    p = ((B/(2*W) + b/2 - c
          + sanctioner_payoff)
         / (s*B/(2*W)
            + (1 - pfo**2)*b/2
            + punished_payoff_without_ploss)
         )
    pr = np.maximum(0, 1 - p)
    return {**models, 'threshold_ps_risk_dominates_au': pr}
